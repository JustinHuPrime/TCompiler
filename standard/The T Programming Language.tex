\documentclass[letterpaper,12pt]{book}

\usepackage{indentfirst}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{verbatim}

% Make chapters display as sections
\renewcommand{\chaptername}{Section}

% Don't put two spaces after a period
\frenchspacing

\begin{document}
\title{The T Programming Language}
\author{Justin Hu}
\maketitle
\tableofcontents

\part{Language}

\setcounter{chapter}{-1} % intro is Sec. 0
\chapter{Introduction}

The T programming language is a C-like, module-based, systems-oriented, procedural language that modernizes several aspects of C. One of the major differences from C is the use of modules, known in other languages as packages. Modules are used in T to support separation of concerns, similar to how C or C++ header files can be used. Unlike the C preprocessor's \texttt{\#include} mechanism, however, the T programming language guarantees that each declaration or code file is only ever lexed and parsed once, leading to faster compilation. However, the T programming language does use the concept of declaration (header) and code (implementation) files to separate the interface of a module from its implementation details. In addition, several features from C++, like function overloading and untagged user-defined structure, union, and enumeration types have been included in the language.

\chapter{Lexicon}

The T programming language uses the basic ASCII character set for both identifiers and operators, and does not support any other character sets. T is case sensitive, like C, but unlike C, T does not support the use of digraphs to represent ASCII characters which may not be supported in other character sets.

There are five general categories of tokens in T, matched on a longest-match basis:

\begin{enumerate}
	\item \textbf{Keywords}: tokens like \texttt{if} and \texttt{struct}, which are used to introduce syntactic elements, or to represent basic language elements.
	\item \textbf{Punctuation}: tokens like \texttt{.} and \texttt{->}, which are used as operators and as part of syntactic elements.
	\item \textbf{Identifiers}: tokens that represent something user-defined.
	\item \textbf{Literals}: tokens that represent a literal value.
	\item \textbf{Whitespace}: tokens that are ignored, or used only as separators between tokens, including comments.
\end{enumerate}

See the file \texttt{tokens.ebnf} for a formal EBNF definition of tokens.

\section{Keywords}

The following words are considered keywords in T:\texttt{\\
module import struct union enum typedef if else while do for switch case default break continue return asm cast sizeof true false void ubyte byte char ushort short uint int wchar ulong long float double bool const}

Keywords are reserved, and may not be used except as a keyword. Note that \texttt{true} and \texttt{false} are considered keywords, rather than literals. The distinction between these two categories in this case is entirely due to the way that these keywords are matched.

\section{Punctuation}

The following symbols are considered punctuation in T:\\
\verb$; , ( ) [ ] { } . -> ++ -- * & + - ! ~ / % << >> >>> <=> < > <= >= == != | ^$\\\verb$&& || ? : = *= /= %= += -= <<= >>= >>>= &= ^= |= &&= ||=$

Note that tokens in T are matched on a longest-match basis, so \verb|---| is considered a decrement (\verb|--|), followed by a minus (\verb|-|), which may or may not be syntactically permissible. There is no attempt to re-lex a failed match to try and find a valid match.

\section{Identifiers}

Identifiers in T are split into two sub-categories: scoped and unscoped identifiers. An unscoped identifier is any sequence of alphanumeric or underscore characters that starts with an alphabetic character or an underscore (similar to the rules for identifiers in C or C++). A scoped identifier consists of a sequence of unscoped identifiers, with two colons (\verb|::|) between them, with absolutely no whitespace allowed. Unlike in C++, the scoping is considered part of the identifier, and not an operator.

On a further note, any identifier beginning with two underscores is reserved, and if such an identifier is used or defined, undefined behaviour may result.

\section{Literals}

T supports integer literals in binary, octal, decimal, or hexadecimal, and supports an optional sign to be included with the literal. To write a binary literal, the prefix \texttt{0b} must be put after the sign, but before the actual number. Octal numbers use the prefix \texttt{0}, and hexadecimal numbers use the prefix \texttt{0x}. Note that the octal prefix of \texttt{0} is distinct from a the literal zero, so a zero written in octal would be written as \texttt{00}.

The floating point literals in T are decimal only, and must be written as a decimal number without the use of scientific notation. NaN and infinity do not have literals in the language. These literals are IEEE 754 binary64 or binary32 numbers.

T also supports string literals, character literals, and the wide variants of both. These literals all support the following escape sequences:

\begin{itemize}
	\item \verb|\n|: produces ASCII character 10, a newline.
	\item \verb|\r|: produces ASCII character 13, a carriage return.
	\item \verb|\t|: produces a tab.
	\item \verb|\0|: produces ASCII character 0, a null.
	\item \verb|\\|: produces a backslash.
	\item \verb|\x|{\textless}hexadecimal digit{\textgreater}{\textless}hexadecimal digit{\textgreater}: produces the ASCII character specified by the two hexadecimal digits, interpreted as an unsigned byte.
\end{itemize}

A character literal consists of a single character, except for a backslash or a single quote, between two single quotes, one of the above escape sequences between two single quotes, or the escape sequence \verb|\'| between two single quotes, which produces a single quote. Note that multi-character literals are forbidden at the lexical level. Also note that a double quote as a character is a literal double quote within single quotes.

A string literal consists of a pair of double quotes, within which may be nothing, or any combination of any character except for double quotes or a backslash, the above escape sequences, or the escape sequence \verb|\"| (representing a literal double quote). Like character literals, a single quote in a string is written as a literal single quote.

The wide variants of both string and character literals are similar to the narrow versions, except that the wide variant has a \texttt{w} at the end of the literal, outside of any quotes, and both wide string and wide character literals may use the escape sequence \verb|\u|{\textless}8 hexadecimal digits{\textgreater}, which produces the UTF-32 character specified by those hexadecimal digits, when interpreted as a big-endian 32 bit integer. Note that any within such a string are interpreted as UTF-32 characters, but since the UTF-32 encodings of any ASCII characters are simple those characters, but zero-extended to fit 32 bits, there are no modifications to the existing literal escape sequences to support wide strings.

\section{Whitespace}

Whitespace in T consists of either spaces, tabs, or newline characters (both linefeed, carriage return, and carriage return-linefeed), or comments. Comments in T are either line comments, which are formed by two slashes, and last until the end of the line or file, or block comments, which start with a slash followed by a star, and end with a star followed by a slash or the end of the file. Block comments do not nest. All whitespace is used solely to separate tokens, and is otherwise lexically meaningless, and thus, ignored.

\chapter{Syntax}

\end{document}
