\documentclass[letterpaper,12pt]{book}

\usepackage{indentfirst}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{verbatim}

% Don't put two spaces after a period
\frenchspacing

\begin{document}
\title{The T Programming Language}
\author{Justin Hu}
\maketitle
\tableofcontents

\part{Language}

\chapter{Introduction}

This document specifies the syntax and semantics of the T programming language, specifically with respect to the implementation of the reference compiler for the language. T is a systems oriented, module-based programming language. The language is statically-typed, with neither classes nor a garbage collector. Conceptually, a T program consists of a set of modules, each module exposing some public interface. An implementation of T takes in the declaration files of the used modules, and code files or linkable files, each of which implement the interface for the modules, and produces an executable. This executable may then be run, in some environment, to produce some sequence of effects.

\section{Compiler Structure}

A T program is translated into an executable in several phases. Since the T grammar is not context free, it is necessary to make multiple passes over the same file. These phases are considered distinct and necessary, and are expected to be present in all compiler implementations.

\begin{enumerate}
	\item \textbf{Lexing}: each declaration and code file is split into a sequence of tokens.

	\item \textbf{Parsing}: the sequence of tokens is parsed into an abstract syntax tree. The parse tree produced depends on the interface of the imported modules, as well as the name of declarations contained in the current module, including those declared after the current point in time in the global scope, this phase is split into two parts.
	\begin{enumerate}
		\item Every global or file scope declaration is inspected, and the declaration's name is recorded. The body of these declarations is left unparsed.
		
		\item Each unparsed body is then parsed using the information from the first pass.
	\end{enumerate}

	\item \textbf{Typechecking}: the program is checked for static type consistency and correctness. As with parsing, this phase is also split over multiple phases.
	\begin{enumerate}
		\item Each global or file scope declaration is inspected, and the details for the declaration are recorded.
		
		\item Traversing through the scopes, each declaration is inspected, and the details for it are recorded. Simultaneously, each identifier is inspected, and matched to an entry.
		
		\item Finally, each expression is checked for type consistency by looking at the sub-expressions that make it up, and by looking at the details recorded for each identifier encountered.
	\end{enumerate}
	
	\item \textbf{Translation}: each code module is translated into a linkable form. This is usually an object code file. The reference compiler translates in several steps.
	\begin{enumerate}
		\item \textbf{Source Code Optimization}: optimizations are performed on the source code's abstract syntax tree. Currently, no optimizations at this level are performed.
		
		\item \textbf{Translation to IR}: each code module is translated into a three-address code form intermediate representation. This translation is independent of the target environment.
		
		\item \textbf{IR Optimization}: optimizations are performed on the intermediate representation. Currently, no optimizations at this level are performed.
		
		\item \textbf{Assembly Generation}: each code module (currently in an intermediate representation) is translated to architecture and environment-specific assembly code. This assembly code, however, does not yet have its stack frames laid out or its register usage resolved.
		
		\item \textbf{Assembly Optimization (part 1)}: optimizations are performed on the register-independent assembly. Currently, no optimizations at this level are performed.
		
		\item \textbf{Register Allocation}: the register usage for each function is resolved, and stack frames are laid out.
		
		\item \textbf{Assembly Optimization (part 2)}: optimizations are performed on the penultimate assembly code. Currently, no optimizations at this level are performed.
		
		\item \textbf{Assembling}: the generated assembly code is assembled into a linkable form. In the reference compiler, this is handled externally by the system assembler. (In Linux, this is the command \texttt{as}.)
	\end{enumerate}
	
	\item \textbf{Linking (optional)}: the generated and supplied are linked into an executable program, or into a shared library. This step is optional if the user wants to produce several object files. In the reference compiler, this is handled externally by the system linker or object-file archiver. (In Linux, these are the commands \texttt{ld} or \texttt{ar}.)
\end{enumerate}

\section{Environment}

A T program is compiled for one or more execution environments, in some translation environment. These environments do not have to be the same. The translation environment must be capable of providing files to the compiler, and must be capable of providing diagnostic messages to the user. The execution environment must be capable of starting execution by calling the main function, and providing the appropriate command line arguments. The environment will be affected by the program through side effects. These side effects must be visible according to the defined semantics. The execution environment must also be capable of handing the return value from the main function. Additionally, the environment must be capable of supporting the implementation and side effects of any standard library modules imported.

\subsection{Character Sets}

In addition to the general requirements above, the translation environment has a character set. This character set contain at least the printable (alphanumeric, symbols) ASCII characters, the space, and the newline. Almost all operating systems provide this environment. The execution environment has its own, possibly distinct character set. There are no requirements on what this character set contains. For the most part, that character set is Unicode.

\chapter{Lexicon}

A source file consists of a sequence of characters. The lexing phase splits these into tokens based on the lexical syntax. The lexical syntax is strict maximal munch. A source file is described by the EBNF below:

\begin{lstlisting}[breaklines=true]
file = { [ whitespace ], token }, [ whitespace ], eof ;

whitespace = " "
           | ? newline ?
           | ? any other implementation-defined whitespace ?
           | "//", ? anything excluding newline ?, newline
           | "/*", ? anything excluding "*/", "*/"
           ;

token = keyword
      | punctuation
      | identifier
      | literal
      ;

keyword = "module" | "import" | "struct" | "union" | "enum"
        | "typedef" | "if" | "else" | "while" | "do" | "for"
        | "switch" | "case" | "default" | "break" | "continue"
        | "return" | "asm" | "cast" | "sizeof" | "true" | "false"
        | "null" | "void" | "ubyte" | "byte" | "char" | "ushort"
        | "short" | "uint" | "int" | "wchar" | "ulong" | "long"
        | "float" | "double" | "bool" | "const"
        ;

punctuation = ";" | "," | "(" | ")" | "[" | "]" | "{" | "}" | "."
            | "->" | "++" | "--" | "*" | "&" | "+" | "-" | "!"
            | "~" | "/" | "%" | "<<" | ">>" | ">>>" | "<=>" | "<"
            | ">" | "<=" | ">=" | "==" | "!=" | "|" | "^" | "&&"
            | "||" | "?" | ":" | "=" | "*=" | "/=" | "%=" | "+="
            | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="
            | "&&=" | "||=" | "::"
            ;

identifier = ( alphabetic | "_" ), { alphabetic | digit | "_" } ;

literal = string_literal
        | char_literal
        | int_literal
        | float_literal
        | wstring_literal
        | wchar_literal
        ;
int_literal = [ "-" | "+" ], nonzero_digit, { digit }
            | "0x", hex_digit, { hex_digit }
            | "0b", binary_digit, { binary_digit }
            | "0", octal_digit, { octal_digit }
            ;
float_literal = [ "-" | "+" ], digit, { digit }, ".", digit, { digit } ;
string_literal = '"', { alphabetic | digit | symbol | escaped | escaped_double_quote | "'" }, '"' ;
char_literal = "'", ( alphabetic | digit | symbol | escaped | escaped_quote | '"' ), "'" ;
wstring_literal = '"', { alphabetic | digit | symbol | escaped | escaped_wchar | escaped_double_quote | "'" } '"w' ;
wchar_literal = "'", ( alphabetic | digit | symbol | escaped | escaped_wchar | escaped_quote | '"' ), "'w" ;

alphabetic = ? any ASCII alphabetic character ?
           | ? any implementation-defined alphabetic characters ?
           ;
nonzero_digit = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
digit = "0"
      | nonzero_digit
      ;
symbol = ? any ASCII symbol plus space ?
       | ? any implementation-defined symbols or spaces ?
       ;
hex_digit = digit
          | "a" | "b" | "c" | "d" | "e" | "f"
          | "A" | "B" | "C" | "D" | "E" | "F"
          ;
binary_digit = "0" | "1" ;
octal_digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" ;
escaped = "\n" | "\r" | "\t" | "\0" | "\\" | "\x", hex_digit, hex_digit ;
escaped_wchar = "\u", hex_digit, hex_digit, hex_digit, hex_digit, hex_digit, hex_digit, hex_digit, hex_digit ;
escaped_quote = "\'" ;
escaped_double_quote = '\"' ;

eof = ? physical end of file ? ;
\end{lstlisting}

\section{Reference Compiler Behaviour}

The reference compiler treats ASCII as its source character set. It defines newline as either the ASCII line feed, the ASCII carriage return, or the ASCII carriage return followed by the ASCII line feed.

\chapter{Syntax}

A source file, once converted into a sequence of tokens, is then converted into a tree of tokens. The provided grammar is context sensitive, and requires at least two passes to parse, since there are disambiguations depending on information about the definition site of a token.

The grammar for a file, without disambiguation rules, is given below. This grammar uses the definitions for given in the lexicon.

\begin{lstlisting}[breaklines=true]
file = module_name, { import }, { function | declaration } ;

module_name = "module", identifier, ";" ;
import = "import", identifier, ";" ;

declaration = function_declaration
            | variable_declaration
            | struct_declaration
            | struct_forward_declaration
            | union_declaration
            | union_forward_declaration
            | enum_declaration
            | enum_forward_declaration
            | typedef_declaration
            ;

function_declaration = type, identifier, "(", [ type, [ identifier ], [ "=", literal ], { ",", type, [ identifier ], [ "=", literal ] } ], ")", ";" ;
variable_declaration = type, identifier, [ "=", literal ], { ",", identifier, [ "=", literal ] }, ";" ;
struct_declaration = "struct", identifier, "{", field_declaration, { field_declaration }, "}", ";" ;
struct_forward_declaration = "struct", identifier, ";" ;
union_declaration = "union", identifier, "{", field_declaration, { field_declaration }, "}", ";" ;
union_forward_declaration = "union", identifier, ";" ;
enum_declaration = "enum", identifier, "{", identifier, { ",", identifier }, [ "," ], "}", ";", ;
enum_forward_declaration = "enum", identifier, ";" ;
typedef_declaration = "typedef", type, identifier, ";" ;
field_declaration = type, identifier, { ",", identifier }, ";" ;

function = type, identifier, "(", [ type, [ identifier, [ "=", literal ] ] ], { ",", type, [ identifier, [ "=", literal ] ] } ], ")", compound_statement ;
statement = compound_statement
          | if_statement
          | while_statement
          | do_while_statement
          | for_statement
          | switch_statement
          | break_statement
          | continue_statement
          | return_statement
          | asm_statement
          | variable_declaration_statement
          | struct_declaration
          | struct_forward_declaration
          | union_declaration
          | union_forward_declaration
          | enum_declaration
          | enum_forward_declaration
          | typedef_declaration
          | expression, ";"
          | ";"
          ;
compound_statement = "{", { statement }, "}" ;
if_statement = "if", "(", expression, ")", statement, [ "else", statement ] ;
while_statement = "while", "(", expression, ")", statement ;
do_while_statement = "do", statement, "while", "(", expression, ")" ;
for_statement = "for", "(", [ variable_declaration | expression ], ";", expression, ";", [ expression ], ")", statement ;
switch_statement = "switch", "(", expression, ")", "{", { "case", ( int_constant | scoped_identifier ), ":", { "case", ( int_constant | scoped_identifier ), ":" }, statement | "default", ":", statement }, "}" ;
break_statement = "break", ";" ;
continue_statement = "continue", ";" ;
return_statement = "return", [ expression ], ";" ;
variable_declaration_statement = type, identifier, [ "=", assignment_expression ], { ",", identifier, [ "=", assignment_expression ] }, ";" ;
asm_statement = "asm", string_constant, ";" ;
expression = assignment_expression
           | assignment_expression, ",", expression
           ;
assignment_expression = ternary_expression
                      | ternary_expression, "=", assignment_expression
                      | ternary_expression, "*=", assignment_expression
                      | ternary_expression, "/=", assignment_expression
                      | ternary_expression, "%=", assignment_expression
                      | ternary_expression, "+=", assignment_expression
                      | ternary_expression, "-=", assignment_expression
                      | ternary_expression, "<<=", assignment_expression
                      | ternary_expression, ">>=", assignment_expression
                      | ternary_expression, ">>>=", assignment_expression
                      | ternary_expression, "&=", assignment_expression
                      | ternary_expression, "^=", assignment_expression
                      | ternary_expression, "|=", assignment_expression
                      | ternary_expression, "&&=", assignment_expression
                      | ternary_expression, "||=", assignment_expression
                      ;
ternary_expression = logical_expression
                   | logical_expression, "?", expression, ":", ternary_expression
                   ;
logical_expression = bitwise_expression, { ( "&&" | "||" ), bitwise_expression } ;
bitwise_expression = equality_expression, { ( "&" | "|" | "^" ), equality_expression } ;
equality_expression = comparison_expression, { ( "==" | "!=" ), comparison_expression } ;
comparison_expression = spaceship_expression, { ( "<" | ">" | "<=" | ">=" ), spaceship_expression } ;
spaceship_expression = shift_expression, { "<=>", shift_expression } ;
shift_expression = addition_expression, { ( "<<" | ">>" | ">>>" ), addition_expression } ;
addition_expression = multiplication_expression, { ( "+" | "-" ), multiplication_expression } ;
multiplication_expression = prefix_expression, { ( "*" | "/" | "%" ), prefix_expression } ;
prefix_expression = postfix_expression
                  | "*", prefix_expression
                  | "&", prefix_expression
                  | "++", prefix_expression
                  | "--", prefix_expression
                  | "-", prefix_expression
                  | "!", prefix_expression
                  | "~", prefix_expression
                  ;
postfix_expression = primary_expression, { ( ( "." | "->" ), identifier | "(", argument_list, ")" | "[", expression, "]" | "++" | "--") } ;
primary_expression = scoped_identifier
                   | identifier
                   | literal
                   | "cast", "[", type, "]", "(", expression, ")"
                   | "sizeof", "(", ( expression | type ), ")"
                   | "(", expression, ")"
                   ;
argument_list = [ assignment_expression, { ",", assignment_expression } ] ;
aggregate_initializer = "[", [ literal, { ",", literal } ], "]" ;
literal = int_constant
        | float_constant
        | string_constant
        | character_constant
        | wstring_constant
        | wcharacter_constant
        | "true"
        | "false"
        | "null"
        | scoped_identifier
        | aggregate_initializer
        ;

type = "void"
     | "ubyte"
     | "byte"
     | "char"
     | "ushort"
     | "short"
     | "uint"
     | "int"
     | "wchar"
     | "ulong"
     | "long"
     | "float"
     | "double"
     | "bool"
     | identifier
     | scoped_identifier
     | type, "const"
     | type, "[", int_constant, "]"
     | type, "*"
     | type, "(", [ type, { ",", type } ], ")"
     ;

scoped_identifier = identifier, "::", identifier
                  | scoped_identifier, "::", identifier
                  ;
\end{lstlisting}

\end{document}
