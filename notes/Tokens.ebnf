(*
This grammar describes valid tokens. Note that longer tokens are preferred over shorter tokens.
Tokens are separated by whitespace
*)
program = { whitespace }, token, { { whitespace }, token } { whitespace } ;
token = keyword
      | punctuation
      | identifier
      | scoped_identifier
      | literal
      ;
whitespace = " "
           | ? ASCII character tab ?
           | ? ASCII character newline ?
           | ? ASCII character carriage-return ?
           | "//", ? anything excluding newline ?, newline
           | "/*", ? anything excluding "*/" ?, "*/"
           ;
keyword = "module" | "using" | "struct" | "union" | "enum" | "typedef" | "if"
        | "else" | "while" | "do" | "for" | "switch" | "case" | "default"
        | "break" | "continue" | "return" | "asm" | "true" | "false" | "cast"
        | "sizeof" | "void" | "ubyte" | "byte" | "uint" | "int" | "ulong"
        | "long" | "float" | "double" | "bool" | "const"
        ;
punctuation = ";" | "," | "(" | ")" | "[" | "]" | "{" | "}" | "." | "->" | "++"
            | "--" | "*" | "&" | "+" | "-" | "!" | "~" | "/" | "%" | "<<"
            | ">>" | ">>>" | "<=>" | "<" | ">" | "<=" | ">=" | "==" | "!="
            | "|" | "^" | "&&" | "||" | "?" | ":" | "=" | "*=" | "/=" | "%="
            | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" | "&&="
            | "||=" | "::"
            ;
identifier = ( alphabetic_character | "_" ), { alphabetic_character | digit_character | "_" } ;
scoped_identifier = identifier { "::", identifier } ;
literal = string_literal
        | char_literal
        | int_literal
        | float_literal
        | wstring_literal
        | wchar_literal
        ;
int_literal = [ "-" | "+" ] { digit_character }+ | "0x", { hex_digit }+ | "0b", { binary_digit }+ | "0", { octal_digit }+  ;
float_literal = [ "-" | "+" ] { digit_character }+, ".", { digit_character }+ ;
string_literal = '"', { alphabetic_character | digit_character | symbol_character | escaped_character | escaped_quote | "'" }, '"' ;
char_literal = "'", ( alphabetic_character | digit_character | symbol_character | escaped_character | escaped_quote ), "'" ;
wstring_literal = '"', { alphabetic_character | digit_character | symbol_character | escaped_character | escaped_utf32_character | escaped_quote | "'" } '"w' ;
wchar_literal = "'", ( alphabetic_character | digit_character | symbol_character | escaped_character | escaped_utf32_character | escaped_quote ), "'w" ;

alphabetic_character = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i"
                     | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r"
                     | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
                     | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I"
                     | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R"
                     | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"
                     ;
nonzero_digit_character = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
digit_character = "0" | nonzero_digit_character ;
symbol_character = " " | "!" | '"' | "#" | "$" | "%" | "&" | "'" | "(" | ")"
                 | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | "<" | "="
                 | ">" | "?" | "@" | "[" | "]" | "^" | "_" | '`' | "{"
                 | "|" | "}" | "~"
                 ;
hex_digit = digit_character
          | "a" | "A" | "b" | "B" | "c" | "C" | "d" | "D" | "e" | "E" | "f"
          | "F"
          ;
binary_digit = "0" | "1" ;
octal_digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" ;
escaped_character = "\n" | "\r" | "\t" | "\0" | "\\" | "\x", hex_digit, hex_digit ;
escaped_utf32_character = "\u", hex_digit, hex_digit, hex_digit, hex_digit, hex_digit, hex_digit, hex_digit, hex_digit ;
escaped_quote = "\'" ;
escaped_double_quote = '\"' ;
newline = ? ASCII character '\n' ?, [ ? ASCII characters '\r' ? ] ;